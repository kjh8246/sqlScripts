-- 다음과 같은 정보를 저장하기 위한 테이블을 만든다.
-- 학생번호, 학생이름, 학생나이, 학생국어점수, 영어점수, 수학점수

CREATE TABLE stu_table(
stu_idx NUMBER ,
stu_name char(10) ,
stu_age NUMBER ,
stu_kor NUMBER ,
stu_eng NUMBER ,
stu_math NUMBER 
);

DROP TABLE STU_TABLE ;

INSERT INTO HR.STU_TABLE
(STU_IDX, STU_NAME, STU_AGE, STU_KOR, STU_ENG, STU_MATH)
VALUES(1111, '홍길동', 30, 100, 80, 70);

SELECT * FROM STU_TABLE st ;

CREATE TABLE number_table(
NUMBER1 NUMBER ,
NUMBER2 NUMBER (3),
NUMBER3 NUMBER (5, 2)
);

INSERT INTO number_table(number1)
VALUES (10000);

SELECT * FROM number_table;

INSERT INTO number_table(number2)
VALUES (100);

SELECT * FROM number_table;

INSERT INTO NUMBER_table(number3)
VALUES (100.1111);

SELECT * FROM NUMBER_TABLE ;

DROP TABLE TBL ;

CREATE TABLE tbl
AS 
SELECT * FROM EMPLOYEES e ;

SELECT * FROM tbl;

-- emp 테이블에서 사원의 번호, 이름, 급여, 정보를 가지고 있는 테이블을 생서하시오
DROP TABLE EMP02 ;

CREATE TABLE emp02
AS 
SELECT EMPLOYEE_ID , FIRST_NAME , SALARY , DEPARTMENT_ID 
FROM EMPLOYEES e2 ;

SELECT * FROM emp02;

-- 30번 부서에 근무하고 있는 사원들의 사원번호, 이름, 근무부서 이름을 가지고 있는 테이블을 생성한다.
DROP TABLE EMP03 ;

CREATE TABLE EMP03 
AS 
SELECT e.EMPLOYEE_ID , e.FIRST_NAME , d.DEPARTMENT_NAME 
FROM EMPLOYEES e, DEPARTMENTS d 
WHERE e.DEPARTMENT_ID = d.DEPARTMENT_ID AND d.DEPARTMENT_ID = 50;

SELECT * FROM EMP03 e ;

-- 각 부서별 급여 총합, 평균, 최고액, 최저액, 사원수를 가지고 있는 테이블을 생성하시오
DROP TABLE EMP04 ;

CREATE TABLE EMP04 
AS 
SELECT SUM(SALARY) AS sum, TRUNC(AVG(SALARY)) AS avg, MAX(SALARY) AS max, 
	   MIN(SALARY) AS min, COUNT(EMPLOYEE_ID) AS count 
FROM EMPLOYEES e 
GROUP BY DEPARTMENT_ID ;

SELECT * FROM EMP04 e ;

----------------제약조건-------------------------------------------------------
DROP TABLE test_table1;

-- NOT NULL : 해당 컬럼에는 NULL을 저장할 수 없다.
CREATE TABLE test_table1(
data1 NUMBER,
data2 NUMBER NOT NULL 
);

INSERT INTO test_table1(data1, data2)
VALUES (100,101);

SELECT * FROM TEST_TABLE1 tt;

INSERT INTO TEST_TABLE1 (DATA1) -- data2 널값 들어감
VALUES (200);

INSERT INTO TEST_TABLE1 (DATA2)
VALUES (201);

SELECT * FROM TEST_TABLE1 tt ;

-- unique : 중복된 값을 허용하지 않고 null은 무한대로 허용한다
DROP TABLE test_table2;

CREATE TABLE test_table2(
data1 NUMBER,
data2 NUMBER CONSTRAINT test_table2_data2_UK unique
);

INSERT INTO TEST_TABLE2 (DATA1, data2)
VALUES (100, 101);

SELECT * FROM TEST_TABLE2 tt ;

INSERT INTO TEST_TABLE2 (DATA1,DATA2)
VALUES (200, 201);

SELECT * FROM TEST_TABLE2 tt ;

INSERT INTO TEST_TABLE2 (DATA1,DATA2)
VALUES (300, 201);

INSERT INTO TEST_TABLE2 (DATA1,DATA2)
VALUES (200,null);

INSERT INTO TEST_TABLE2 (DATA1)
VALUES (200);

SELECT * FROM TEST_TABLE2 tt ;

-- primary key : 중복을 허용하지 않고 null을 허용하지 않는다. (not null + unique)
DROP TABLE TEST_TABLE3 ;

CREATE TABLE TEST_TABLE3(
data1 NUMBER,
date2 NUMBER CONSTRAINT test_table_data2_pk PRIMARY KEY 
);

INSERT INTO TEST_TABLE3 (DATA1, DATE2)
VALUES (100, 101);

SELECT * FROM TEST_TABLE3 tt ;

INSERT INTO TEST_TABLE3 (DATA1, DATE2) -- 오류 중복
VALUES (100, 101); 

INSERT INTO TEST_TABLE3 (DATA1) -- 오류 널
VALUES (100);

-- 외래키 : 특정 테이블의 컬럼을 참조하는 제약조건 (널은 무한히 가능)
DROP TABLE TEST_TABLE4;
DROP TABLE TEST_TABLE5;

CREATE TABLE test_table4(
DATA1 NUMBER CONSTRAINT test_table4_pk PRIMARY KEY,
DATA2 NUMBER NOT NULL 
);

INSERT INTO TEST_TABLE4 (DATA1,DATA2)
VALUES (100,101);

INSERT INTO TEST_TABLE4 (DATA1,DATA2)
VALUES (200,201);

SELECT * FROM TEST_TABLE4 tt ;

CREATE TABLE TEST_TABLE5(
DATE3 NUMBER NOT NULL,
DATE4 NUMBER CONSTRAINT test_table5_data4_fk
						REFERENCES test_table4(data1)
);

INSERT INTO TEST_TABLE5 (DATE3,DATE4)
VALUES (1, 100);

INSERT INTO TEST_TABLE5 (DATE3,DATE4)
VALUES (2, 100);

INSERT INTO TEST_TABLE5 (DATE3,DATE4)
VALUES (3, 200);

INSERT INTO TEST_TABLE5 (DATE3,DATE4)
VALUES (4, 200);

SELECT * FROM TEST_TABLE5 tt ;

INSERT INTO TEST_TABLE5 (DATE3,DATE4)
VALUES (5, null)

INSERT INTO TEST_TABLE5 (DATE3)
VALUES (6);

SELECT * FROM TEST_TABLE5 tt ;

INSERT INTO TEST_TABLE5 (DATE3,DATE4) -- 오류 test_table4(data1)에 저장안된 값
VALUES (7, 300);

-- check 제약조건 : 컬럼에 저장될 값을 지정한다.
DROP TABLE TEST_TABLE6;

CREATE TABLE TEST_TABLE6(
data1 NUMBER CONSTRAINT test_table6_data1_ck
			 CHECK (data1 BETWEEN 1 AND 10),
data2 NUMBER CONSTRAINT test_table6_data2_ck
			 CHECK (data2 IN(10, 20, 30))
);

INSERT INTO TEST_TABLE6 (DATA1,DATA2)
VALUES (1,10);

INSERT INTO TEST_TABLE6 (DATA1,DATA2)
VALUES (2,20);

SELECT * FROM TEST_TABLE6 tt ;

INSERT INTO TEST_TABLE6 (DATA1,DATA2) -- data2 오류
VALUES (20,10);

INSERT INTO TEST_TABLE6 (DATA1,DATA2) -- data1 오류
VALUES (5,100);

-- 컬럼 레벨
DROP TABLE TEST_TABLE10;

CREATE TABLE TEST_TABLE10(
data1 NUMBER CONSTRAINT test_table10_data1_pk PRIMARY KEY ,
data2 NUMBER NOT NULL CONSTRAINT test_table10_data2_uk UNIQUE ,
data3 NUMBER NOT NULL CONSTRAINT test_table10_data3_fk
						REFERENCES employees(EMPLOYEE_ID),
data4 NUMBER NOT NULL CONSTRAINT test_table10_data4_ck
						CHECK(data4 BETWEEN 1 and 10),
data5 NUMBER NOT NULL CONSTRAINT test_table10_data5_ck
						check(data5 IN(10, 20, 30))
);
-- 테이블 레벨 제약조건
DROP TABLE TEST_TABLE11;

CREATE TABLE TEST_TABLE11(
data1 NUMBER ,
data2 NUMBER NOT NULL ,
data3 NUMBER NOT NULL ,
data4 NUMBER NOT NULL ,
data5 NUMBER NOT NULL ,

CONSTRAINT test_table11_data1_pk PRIMARY KEY(data1),
CONSTRAINT test_table11_data2_uk UNIQUE (data2),
CONSTRAINT test_table11_data3_fk FOREIGN KEY(data3) 
								 REFERENCES employees(EMPLOYEE_ID),
CONSTRAINT test_table11_data4_ck CHECK (data4 BETWEEN 1 AND 10),
CONSTRAINT test_table11_data5_ck CHECK (data5 IN(10, 20, 30))
);

-- 복합키 
DROP TABLE TEST_TABLE12;

CREATE TABLE TEST_TABLE12(
data1 NUMBER,
data2 NUMBER,

CONSTRAINT test_table12_combo_pk PRIMARY KEY (data1, data2)
);

INSERT INTO TEST_TABLE12 (data1, data2)
VALUES (100, 200);

INSERT INTO test_table12 (data1, data2)
VALUES (100, 300);

INSERT INTO test_table12 (data1, data2)
VALUES (400, 200);

SELECT * FROM TEST_TABLE12 tt ;

INSERT INTO TEST_TABLE12 (data1, data2) -- 오류 복합키는 모든컬럼이 중복이 허용되지 않음
VALUES (100, 200);

-- 제약조건 추가하기
DROP TABLE TEST_TABLE20; 

CREATE TABLE test_table20(
data1 NUMBER,
data2 NUMBER,
data3 NUMBER,
data4 NUMBER,
data5 NUMBER,
data6 NUMBER 
);

-- null 제약조건 추가
ALTER TABLE TEST_TABLE20 
MODIFY data1 NOT NULL ;

INSERT INTO TEST_TABLE20 (DATA1) --오류발생 null
VALUES (null);

-- primary key 제약조건 추가
ALTER TABLE TEST_TABLE20 
ADD CONSTRAINT test_table20_data2_pk PRIMARY KEY(data2);

INSERT INTO TEST_TABLE20 (DATA1, DATA2)
VALUES (1, 10);

INSERT INTO TEST_TABLE20 (DATA1, DATA2) -- 오류 중복
VALUES (2, 10);

INSERT INTO TEST_TABLE20 (DATA1, DATA2) -- 오류 널
VALUES (3, null);

ALTER TABLE TEST_TABLE20 
ADD CONSTRAINT test_table20_data3_fk FOREIGN KEY(data3)
				REFERENCES employees(EMPLOYEE_ID);

INSERT INTO TEST_TABLE20 (DATA1, DATA2, DATA3)
VALUES (10, 90, 100);

INSERT INTO TEST_TABLE20 (DATA1, DATA2, DATA3) -- 오류 90은 employee_id에 없음
VALUES (11, 202, 90);

-- unique 제약 조건 추가
ALTER TABLE TEST_TABLE20
ADD CONSTRAINT test_table20_data4_uk UNIQUE(data4);

INSERT INTO TEST_TABLE20 (DATA1, DATA2, DATA4)
VALUES (12, 102, 200);

INSERT INTO TEST_TABLE20 (DATA1, DATA2, DATA4)
VALUES (13, 103, 101);

SELECT * FROM TEST_TABLE20 tt ;

-- check 제약조건
ALTER TABLE TEST_TABLE20 
ADD CONSTRAINT test_table20_data5_ck check(data5 BETWEEN 1 AND 10);

INSERT INTO TEST_TABLE20 (DATA1, DATA2, DATA5)
VALUES (14, 104, 5);

INSERT INTO TEST_TABLE20 (DATA1, DATA2, DATA5)
VALUES (15, 105, 20);

ALTER TABLE TEST_TABLE20 
ADD CONSTRAINT test_table20_data6_ck check(data6 IN(10, 20, 30));

INSERT INTO TEST_TABLE20 (DATA1, DATA2, DATA6)
VALUES (16, 106, 20);

INSERT INTO TEST_TABLE20 (DATA1, DATA2, DATA6)
VALUES (17, 107, 50);


SELECT * FROM TEST_TABLE20 tt ;

CREATE TABLE TEST_TABLE30(
data1 NUMBER NOT NULL ,
data2 NUMBER CONSTRAINT test_table30_data2_pk PRIMARY KEY ,
data3 NUMBER CONSTRAINT test_table30_data3_fk 
			 REFERENCES employees(EMPLOYEE_ID),
data4 NUMBER CONSTRAINT test_table30_data4_uk UNIQUE,
data5 NUMBER CONSTRAINT test_table30_data5_ck
			 CHECK (data5 BETWEEN 1 AND 10),
data6 NUMBER CONSTRAINT test_table30_data6_ck
			 CHECK (data6 IN (10, 20, 30))
			 
);
-- not null 제약조건 제거
ALTER TABLE test_table30
MODIFY data1 NULL ;

INSERT INTO TEST_TABLE30 (DATA1, DATA2)
VALUES (NULL, 100);

-- primary key 제약조건 제거
ALTER TABLE TEST_TABLE30 
DROP CONSTRAINT test_table30_data2_pk;

INSERT INTO TEST_TABLE30 (DATA2)
VALUES (null)

-- 외래키 제약조건 제거
ALTER TABLE TEST_TABLE30 
DROP CONSTRAINT test_table30_data3_fk ;

INSERT INTO TEST_TABLE30 (DATA3)
VALUES (1000);

-- nuique 제약조건 제거
ALTER TABLE TEST_TABLE30 
DROP CONSTRAINT test_table30_data4_uk ;

INSERT INTO TEST_TABLE30 (DATA4)
VALUES (100);
INSERT INTO TEST_TABLE30 (DATA4)
VALUES (100);

-- 채크 제약조건 제거
ALTER TABLE TEST_TABLE30 
DROP CONSTRAINT test_table30_data5_ck ;

ALTER TABLE TEST_TABLE30 
DROP CONSTRAINT test_table30_data_ck ;

INSERT INTO TEST_TABLE30 (DATA5, DATA6)
VALUES (20 , 100);

SELECT * FROM TEST_TABLE30 tt;

CREATE TABLE TEST_TABLE40(
data1 NUMBER CONSTRAINT test_table40_data1_pk PRIMARY KEY 
);

INSERT INTO TEST_TABLE40 (DATA1)
VALUES (100);

INSERT INTO test_table40 (DATA1)
VALUES (100);

SELECT * FROM TEST_TABLE40 tt ;

ALTER TABLE TEST_TABLE40 
disable CONSTRAINT test_table40_data1_pk;

INSERT INTO test_table40 (DATA1)
VALUES (100);

SELECT * FROM TEST_TABLE40 tt ;

ALTER TABLE TEST_TABLE40 
emable CONSTRAINT test_table40_data1_pk;

DELETE FROM TEST_TABLE40 tt ;

INSERT INTO test_table40 (DATA1)
VALUES (100);

INSERT INTO test_table40 (DATA1)
VALUES (200);

ALTER TABLE TEST_TABLE40 
enable CONSTRAINT test_table40_data1_pk;

INSERT INTO test_table40 (DATA1)
VALUES (200);

-- 테이블 구조 변경하기
DROP TABLE TEST_TABLE1 ;

CREATE TABLE TEST_TABLE1 (
data1 NUMBER NOT NULL ,
data2 NUMBER NOT NULL 
);

-- 컬럼추가
ALTER TABLE TEST_TABLE1 
ADD (data3 NUMBER NOT NULL );

-- 컬럼의 데이터 타입 변경
ALTER TABLE TEST_TABLE1 
MODIFY (data3 varchar2(100));

-- 테이블 이름 변경
DROP TABLE test_table2;

ALTER TABLE TEST_TABLE1 
RENAME TO test_table2;

-- 컬럼 이름 변경
ALTER TABLE TEST_TABLE2 
RENAME COLUMN data3 TO data4;

-- 컬럼 삭제
ALTER TABLE TEST_TABLE2 
DROP column data4;

-- 테이블 삭제
DROP TABLE test_table2;










